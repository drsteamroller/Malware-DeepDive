# notPetya: Static Analysis

## 1. TrIDNET & Detect it Easy

Let's first figure out what we've got. When I unzipped the "theZoo" archive, it presented me with 2 binary files. Sparing the long hex names, the files are 788 KB and 226 KB. Let's take a look at TrIDNET and Detect it Easy to see what their actual file definitions are:

> **Larger File**<p>
<img title="Larger File [TrIDNET]" src="images/tridnetLF.png">
<img title="Larger File [Detect it Easy]" src="images/diteLF.png">
</p>

> **Smaller File**<p>
<img title="Smaller File [TrIDNET]" src="images/tridnetSF.png">
<img title="Smaller File [Detect it Easy]" src="images/diteSF.png">
</p>

So it seems as if the larger file is the main executable, and the smaller one is something peculiar. Basing my thoughts off first looks, I would guess that this file is injected somewhere (the Control Panel perhaps) and could be a way to obtain root/admin priveleges. That or it could be 2 different versions of Petya. We'll know for sure when we get to dynamic analysis.

A very top-level research of CPL files **[1]** tells us that they are used as an interface for system drivers. It isn't super uncommon that 3rd party hardware/software include these CPLs as part of their driver- for example, the on-board network adapter for a computer would need to include one for troubleshooting. This hints towards a possible method for persistence. 

## 2. Strings

As you do in digital forensics, I copied the two files to a separate workspace and renamed the larger file to "PetyaPayload" and the smaller one "PetyaPersist". The latter might change as we get a better idea as to what it's purpose is.

Scrolling on through the strings of PetyaPayload, I found XML-like structure similar to what CPL files are supposed to look like **[2]**. It could be that the program is broken up between 2 executables, or like I said before, it could be 2 versions of Petya. 

The content however is interesting. I see that it calls itself "Microsoft.Windows.Common-Controls", and there's a "<description>" with the text "WinRAR SFX module". This could be part of the masquerading/social engineering that ransomwares like Petya and Wana Decrypt0r rely on in order to infect machines. Nothing else stuck out to me in the strings of the "payload", let's move onto the "persist" file.

I only really found the same CPL structure with the same exact information in PetyaPersist, which leads me to believe these are both Petya, but we still have more to look through.

## 3. Disassembly & Decompilation

Jumping right into Ghidra for decompilation, the entry function at a glance looks like a bunch of initializations, with error handling that will be explored later. Here is the first part of the entry function, with the first initialization:
```c
int entry(void)

{
  int statusCodeFetcher;
  _STARTUPINFOW StartupInfo;
  int local_24;
  int local_20;
  astruct *uStack12;
  astruct_1 *local_8;
  
  ___security_init_cookie();
  local_8 = (astruct_1 *)&DAT_004849c0;
  uStack12 = (astruct *)0x44d21c;
```
Two important variable declarations that are used in the main function are a integer, which I've renamed "statusCodeFetcher", and a \_STARTUPINFOW struct **[3]** I aptly renamed "StartupInfo". statusCodeFetcher is used to grab the return codes from each of the initializers, and then it is compared in if statements to determine if the program needs to exit. StartupInfo grabs the \_STARTUPINFOW struct that returns from the GetStartupInfoW function. There's also a call to \_security_init_cookie() which is buffer overrun protection. I had never heard about buffer overrun before, but in laymans terms: buffer overflows have to do with overwriting a buffer; buffer overruns are when you over-*read* a buffer. This is mainly just housekeeping on C-Runtime's part, but it's nice to explore this as a novice/intermediate reverse engineer, and to see if the malware authors including anything subtle.

Lastly, the 2 struct variables are assigned some values. I thought that they could be some sort of strings, but the ascii didn't line up so they're just data until we see when they're used.

### A) Initializers

The first initializer in the set calls the HeapSetInformation function **[4]**. Before that though, the function first calls GetStartupInfoW and stores the result in the StartupInfo variable, dereferenced. It then runs through an if statement comparing *some variable* to zero. I have somewhat of a guess as to what this variable is, but it should be a little easier to understand when we start debugging. The GetStartupInfoW function returns a \_STARTUPINFOW struct, and I'm guessing that this variable being compared to zero is some variable in the struct (i.e. StartupInfo[x]).

The variables passed into HeapSetInformation are all zero, except a HeapEnableTerminationOnCorruption flag. This flag is self-explanatory for the most part, if the program detects an error in a heap, it notifies Windows Error Reporting, and then terminates the program/process. This initialization looks harmless for the most part, and might even be required for any CRT/executable program.

Looking deeper into \_security_init_cookie(), there's a call to GetTickCount() which the result is then XOR'ed with the system time, current process ID, current thread ID, and a performance counter. The result of all the XOR operations is stored into a global variable I renamed "SUS_GLOB_VAR". There's another global variable stored as the bitwise 'not' of this variable, which I've renamed "'not'SUS_GLOB_VAR" I know that anti-forensics efforts include checking how much time the process is taking to run, hence the GetTickCount(), though it doesn't seem to be exiting the program outright in \_security_init_cookie(). I looked at XREFs to "SUS_GLOB_VAR" and in pretty much every instance of it being used, it is being XOR'ed with a stack variable, which was often times very high up in the stack. While tracing "SUS_GLOB_VAR" around until I landed on a function that uses it to exit. This function (renamed "terminate_if_debugger_present") uses both the renamed variables above and also calls "IsDebuggerPresent()", and based on the result, the process is ended with exit code 0xc0000409. This will make debugging and dynamic analysis interesting and difficult to say the least. Jump to after the initializers section for XREFs for the "terminate_if_debugger_present" function.

---

The following initializer is \__heap_init() a \_\_heap_init() function call, with the return variable being stored in statusCodeFetcher. If the status code is zero, it will call \_fast_error_exit() which at face value, seems to be a function that exits the program/process *fast*. What this could mean is that it bypasses some safeguards or Windows/C Runtime cleanup functions, but we won't know for sure. The 0x1c is just the error message/code, from what I can tell there isn't anything special being done with this hex. I will explore \_fast_error_exit more in depth later as it's called another time (& there's a decent amount to code to sift through in it).

\__heap_init() itself just uses the HeapCreate function **[5]** with the parameters (a. 0, b. 0x1000, c. 0). These mean, respectively: a. the heap is initialized with no special options, b. with initial size of 0x1000 (4096) bytes, and c. it can grow. \__heap_init() then returns 0 or 1 if the HeapCreate function was unsuccessful or successful, respectively.

---

The next one is \__mtinit(). \__<u>mt</u>init most likely stands for multitask initialization. Combing through the function it doesn't look like it's doing anything past allocating and creating fibers and fiber/thread local storage(F/TLS). I go over fibers and FLS in the **Notes** section.

---

After mtinit, there's \__ioinit(), which I'm assuming is input/output initialiation. The function is pretty long and has a lot of bitwise operations and Critical section initialization.

---

Everything after that has to do with setting up/fetching environment variables and setting up its own environment. Nothing that points to mal-operations of any sort, except for \_security_init_cookie() and the anti-forensic function.

### \<END\> A) Initializers

Continuing to look into XREFs for "terminate_if_debugger_present", I found that it's used in this huge function that seems to have multiple purposes, but one recognizable one is that it tries to update Java. It also opens Registry Keys with the specific location being ""SOFTWARE\\JavaSoft\\Java Update\\Policy\\jucheck". I'm not sure if this is necessarily malicious, as other apps that rely on an up-to-date Java instance might need to run this code too, but I'm not 100% sure. This also could be some sort of misdirection while the program opens up other keys in other threads. One last thing that comes to mind is this might also be a way to trick the user into thinking that the program needs admin privileges to update java in order to view the "pdf" (which is how notPetya usually presents itself as). But all this remains speculation. Nothing I've researched so far has hinted that notPetya even uses Java, so this could also be a C/Windows Runtime thing, or just how Ghidra decompiles binaries (Ghidra is a Java Program).

That being said, terminate_if_debugger_present is used A LOT, so I'll have a lot of combing through to see if there's any other malware-hinting operations tied to this function.

## Notes (more for me to learn, not really useful malware info)

Getting into the meat of \__mtinit(), it looks like it has to do heavily with *fibers* and *fiber local storage* (FLS). From what I know about threads (which isn't a whole lot) I know that they are scheduled by the processor (not the program- I think) and ran from the main execution from a process. Fibers [6] are essentially the same thing except they are scheduled and ran by the thread that created them. FLS is essentially the same as thread local storage (TLS), which stores variables and other data structures relevant to a certain thread, except that these variables are available to all fibers in a thread. Fibers are ran when they are "switched to," and I couldn't find anything that described or demonstrated this further other than there is a "SwitchToFiber" function, which probably then executes the fiber's instructions. 

## References

[1] https://support.microsoft.com/en-us/topic/description-of-control-panel-cpl-files-4dc809cd-5063-6c6d-3bee-d3f18b2e0176

[2] https://docs.fileformat.com/system/cpl/#:~:text=A%20CPL%20file%20is%20short,Displays%2C%20Networking%2C%20amongst%20others

[3] https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow (StartupInfoW struct)

[4] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapsetinformation (HeapSetInformation function)

[5] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate (HeapCreate function)

[6] https://docs.microsoft.com/en-us/windows/win32/procthread/fibers