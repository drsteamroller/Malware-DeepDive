# notPetya: Static Analysis

## 1. TrIDNET & Detect it Easy

Let's first figure out what we've got. When I unzipped the "theZoo" archive, it presented me with 2 binary files. Sparing the long hex names, the files are 788 KB and 226 KB. Let's take a look at TrIDNET and Detect it Easy to see what their actual file definitions are:

> **Larger File**<p>
<img title="Larger File [TrIDNET]" src="images/tridnetLF.png">
<img title="Larger File [Detect it Easy]" src="images/diteLF.png">
</p>

> **Smaller File**<p>
<img title="Smaller File [TrIDNET]" src="images/tridnetSF.png">
<img title="Smaller File [Detect it Easy]" src="images/diteSF.png">
</p>

So it seems as if the larger file is the main executable, and the smaller one is something peculiar. Basing my thoughts off first looks, I would guess that this file is injected somewhere (the Control Panel perhaps) and could be a way to obtain root/admin priveleges. That or it could be 2 different versions of Petya. We'll know for sure when we get to dynamic analysis.

A very top-level research of CPL files **[1]** tells us that they are used as an interface for system drivers. It isn't super uncommon that 3rd party hardware/software include these CPLs as part of their driver- for example, the on-board network adapter for a computer would need to include one for troubleshooting. This hints towards a possible method for persistence. 

## 2. Strings

As you do in digital forensics, I copied the two files to a separate workspace and renamed the larger file to "PetyaPayload" and the smaller one "PetyaPersist". The latter might change as we get a better idea as to what it's purpose is.

Scrolling on through the strings of PetyaPayload, I found XML-like structure similar to what CPL files are supposed to look like **[2]**. It could be that the program is broken up between 2 executables, or like I said before, it could be 2 versions of Petya. 

The content however is interesting. I see that it calls itself "Microsoft.Windows.Common-Controls", and there's a "<description>" with the text "WinRAR SFX module". This could be part of the masquerading/social engineering that ransomwares like Petya and Wana Decrypt0r rely on in order to infect machines. Nothing else stuck out to me in the strings of the "payload", let's move onto the "persist" file.

I only really found the same CPL structure with the same exact information in PetyaPersist, which leads me to believe these are both Petya, but we still have more to look through.

## 3. Disassembly & Decompilation

Jumping right into Ghidra for decompilation, the entry function at a glance looks like a bunch of initializations, with error handling that will be explored later. Here is the first part of the entry function, with the first initialization:
```c
int entry(void)

{
  int statusCodeFetcher;
  _STARTUPINFOW StartupInfo;
  int local_24;
  int local_20;
  astruct *uStack12;
  astruct_1 *local_8;
  
  ___security_init_cookie();
  local_8 = (astruct_1 *)&DAT_004849c0;
  uStack12 = (astruct *)0x44d21c;
```
Two important variable declarations that are used in the main function are a integer, which I've renamed "statusCodeFetcher", and a \_STARTUPINFOW struct **[3]** I aptly renamed "StartupInfo". statusCodeFetcher is used to grab the return codes from each of the initializers, and then it is compared in if statements to determine if the program needs to exit. StartupInfo grabs the \_STARTUPINFOW struct that returns from the GetStartupInfoW function. There's also a call to \_security_init_cookie() which is buffer overrun protection. I had never heard about buffer overrun before, but in laymans terms: buffer overflows have to do with overwriting a buffer; buffer overruns are when you over-*read* a buffer. This is mainly just housekeeping on C-Runtime's part, but it's nice to explore this as a novice/intermediate reverse engineer, and to see if the malware authors including anything subtle.

Lastly, the 2 struct variables are assigned some values. I thought that they could be some sort of strings, but the ascii didn't line up so they're just data until we see when they're used.

### A) Initializers

The first initializer in the set calls the HeapSetInformation function **[4]**. Before that though, the function first calls GetStartupInfoW and stores the result in the StartupInfo variable, dereferenced. It then runs through an if statement comparing *some variable* to zero. I have somewhat of a guess as to what this variable is, but it should be a little easier to understand when we start debugging. The GetStartupInfoW function returns a \_STARTUPINFOW struct, and I'm guessing that this variable being compared to zero is some variable in the struct (i.e. StartupInfo[x]).

The variables passed into HeapSetInformation are all zero, except a HeapEnableTerminationOnCorruption flag. This flag is self-explanatory for the most part, if the program detects an error in a heap, it notifies Windows Error Reporting, and then terminates the program/process. This initialization looks harmless for the most part, and might even be required for any CRT/executable program.

---

The following initializer is \__heap_init() a \_\_heap_init() function call, with the return variable being stored in statusCodeFetcher. If the status code is zero, it will call \_fast_error_exit() which at face value, seems to be a function that exits the program/process *fast*. What this could mean is that it bypasses some safeguards or Windows/C Runtime cleanup functions, but we won't know for sure. The 0x1c is just the error message/code, from what I can tell there isn't anything special being done with this hex. I will explore \_fast_error_exit more in depth later as it's called another time (& there's a decent amount to code to sift through in it).

\__heap_init() itself just uses the HeapCreate function **[5]** with the parameters (a. 0, b. 0x1000, c. 0). These mean, respectively: a. the heap is initialized with no special options, b. with initial size of 0x1000 (4096) bytes, and c. it can grow. \__heap_init() then returns 0 or 1 if the HeapCreate function was unsuccessful or successful, respectively.

---

The next one is \__mtinit(). \__<u>mt</u>init most likely stands for multitask initialization. Combing through the function it doesn't look like it's doing anything past allocating and creating fibers and fiber/thread local storage(F/TLS). I go over fibers and FLS in the **Notes** section.

---

After mtinit, there's \__ioinit(), which I'm assuming is input/output initialiation. The function is pretty long and has a lot of bitwise operations and Critical section initialization.

---

Everything after that has to do with setting up/fetching environment variables and setting up its own environment.

## Notes (more for me to learn)

Getting into the meat of \__mtinit(), it looks like it has to do heavily with *fibers* and *fiber local storage* (FLS). From what I know about threads (which isn't a whole lot) I know that they are scheduled by the processor (not the program- I think) and ran from the main execution from a process. Fibers [6] are essentially the same thing except they are scheduled and ran by the thread that created them. FLS is essentially the same as thread local storage (TLS), which stores variables and other data structures relevant to a certain thread, except that these variables are available to all fibers in a thread. Fibers are ran when they are "switched to," and I couldn't find anything that described or demonstrated this further other than there is a "SwitchToFiber" function, which probably then executes the fiber's instructions. 

## References

[1] https://support.microsoft.com/en-us/topic/description-of-control-panel-cpl-files-4dc809cd-5063-6c6d-3bee-d3f18b2e0176

[2] https://docs.fileformat.com/system/cpl/#:~:text=A%20CPL%20file%20is%20short,Displays%2C%20Networking%2C%20amongst%20others

[3] https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow (StartupInfoW struct)

[4] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapsetinformation (HeapSetInformation function)

[5] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate (HeapCreate function)

[6] https://docs.microsoft.com/en-us/windows/win32/procthread/fibers