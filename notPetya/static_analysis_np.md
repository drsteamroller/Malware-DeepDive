# notPetya: Static Analysis

## 1. TrIDNET & Detect it Easy

Let's first figure out what we've got. When I unzipped the "theZoo" archive, it presented me with 2 binary files. Sparing the long hex names, the files are 788 KB and 226 KB. Let's take a look at TrIDNET and Detect it Easy to see what their actual file definitions are:

> **Larger File**<p>
<img title="Larger File [TrIDNET]" src="images/tridnetLF.png">
<img title="Larger File [Detect it Easy]" src="images/diteLF.png">
</p>

> **Smaller File**<p>
<img title="Smaller File [TrIDNET]" src="images/tridnetSF.png">
<img title="Smaller File [Detect it Easy]" src="images/diteSF.png">
</p>

So it seems as if the larger file is the main executable, and the smaller one is something peculiar. Basing my thoughts off first looks, I would guess that this file is injected somewhere (the Control Panel perhaps) and could be a way to obtain root/admin priveleges. That or it could be 2 different versions of Petya. We'll know for sure when we get to dynamic analysis. (Coming back to this from the future, I'm almost certain these are two different versions of the same malware.)

A very top-level research of CPL files **[1]** tells us that they are used as an interface for system drivers. It isn't super uncommon that 3rd party hardware/software include these CPLs as part of their driver- for example, the on-board network adapter for a computer would need to include one for troubleshooting. This hints towards a possible method for persistence. 

## 2. Strings

As you do in digital forensics, I copied the two files to a separate workspace and renamed the larger file to "PetyaPayload" and the smaller one "PetyaPersist". The latter might change as we get a better idea as to what it's purpose is.

Scrolling on through the strings of PetyaPayload, I found XML-like structure similar to what CPL files are supposed to look like **[2]**. It could be that the program is broken up between 2 executables, or like I said before, it could be 2 versions of Petya. 

The content however is interesting. I see that it calls itself "Microsoft.Windows.Common-Controls", and there's a "<description>" with the text "WinRAR SFX module". This could be part of the masquerading/social engineering that ransomwares like Petya and Wana Decrypt0r rely on in order to infect machines. Nothing else stuck out to me in the strings of the "payload", let's move onto the "persist" file.

I only really found the same CPL structure with the same exact information in PetyaPersist, which leads me to believe these are both Petya, but we still have more to look through.

## 3. PE Studio

I've never used PE Studio before, but it looks very helpful in identifying blacklisted strings and imported functions so we can take a guess as to what the malware will be doing with them. Note: I'm actually doing this after my Ghidra analysis in **Disassembly & Decompilation** but I plan on utilizing PE Studio before I look at disassembly from now on.

I'm going to ignore the first couple of tabs since they have information that is constant in all executables, and are virus checks (we already know this is a virus).

Of the 14 imported libraries, 3 are blacklisted: wininet.dll, wintrust.dll, and crypt32.dll. There are additionally blacklisted functions that are imported from shell32.dll, user32.dll, kernel32.dll, and advapi32.dll. There are in total 64 functions blacklisted so I won't analyze them all in detail. I've included a text document of all the blacklisted functions in blacklisted_functions.txt. 

## 4. Disassembly & Decompilation

Jumping right into Ghidra for decompilation, the entry function at a glance looks like a bunch of initializations, with error handling that will be explored later. Here is the first part of the entry function, with the first initialization:
```c
int entry(void)

{
  int statusCodeFetcher;
  _STARTUPINFOW StartupInfo;
  int local_24;
  int local_20;
  astruct *uStack12;
  astruct_1 *local_8;
  
  ___security_init_cookie();
  local_8 = (astruct_1 *)&DAT_004849c0;
  uStack12 = (astruct *)0x44d21c;
```
Two important variable declarations that are used in the main function are a integer, which I've renamed "statusCodeFetcher", and a \_STARTUPINFOW struct **[3]** I aptly renamed "StartupInfo". statusCodeFetcher is used to grab the return codes from each of the initializers, and then it is compared in if statements to determine if the program needs to exit. StartupInfo grabs the \_STARTUPINFOW struct that returns from the GetStartupInfoW function. There's also a call to \_security_init_cookie() which is buffer overrun protection. I had never heard about buffer overrun before, but in laymans terms: buffer overflows have to do with overwriting a buffer; buffer overruns are when you over-*read* a buffer. This is mainly just housekeeping on C-Runtime's part, but it's nice to explore this as a novice/intermediate reverse engineer, and to see if the malware authors including anything subtle.

Lastly, the 2 struct variables are assigned some values. I thought that they could be some sort of strings, but the ascii didn't line up so they're just data until we see when they're used.

Looking deeper into \_security_init_cookie(), there's a call to GetTickCount() which the result is then XOR'ed with the system time, current process ID, current thread ID, and a performance counter. The result of all the XOR operations is stored into a global variable I renamed "SUS_GLOB_VAR". There's another global variable stored as the bitwise 'not' of this variable, which I've renamed "'not'SUS_GLOB_VAR" I know that anti-forensics efforts include checking how much time the process is taking to run, hence the GetTickCount(), though it doesn't seem to be exiting the program outright in \_security_init_cookie(). I looked at XREFs to "SUS_GLOB_VAR" and in pretty much every instance of it being used, it is being XOR'ed with a stack variable, which was often times very high up in the stack. While tracing "SUS_GLOB_VAR" around until I landed on a function that uses it to exit. This function (renamed "terminate_if_debugger_present") uses both the renamed variables above and also calls "IsDebuggerPresent()", and based on the result, the process is ended with exit code 0xc0000409. This will make debugging and dynamic analysis interesting and difficult to say the least. Jump to after the initializers section for XREFs for the "terminate_if_debugger_present" function.

### A) Initializers

The first initializer in the set calls the HeapSetInformation function **[4]**. Before that though, the function first calls GetStartupInfoW and stores the result in the StartupInfo variable, dereferenced. It then runs through an if statement comparing *some variable* to zero. I have somewhat of a guess as to what this variable is, but it should be a little easier to understand when we start debugging. The GetStartupInfoW function returns a \_STARTUPINFOW struct, and I'm guessing that this variable being compared to zero is some variable in the struct (i.e. StartupInfo[x]).

The variables passed into HeapSetInformation are all zero, except a HeapEnableTerminationOnCorruption flag. This flag is self-explanatory for the most part, if the program detects an error in a heap, it notifies Windows Error Reporting, and then terminates the program/process. This initialization looks harmless for the most part, and might even be required for any CRT/executable program.

---

The following initializer is \__heap_init() a \_\_heap_init() function call, with the return variable being stored in statusCodeFetcher. If the status code is zero, it will call \_fast_error_exit() which at face value, seems to be a function that exits the program/process *fast*. What this could mean is that it bypasses some safeguards or Windows/C Runtime cleanup functions, but we won't know for sure. The 0x1c is just the error message/code, from what I can tell there isn't anything special being done with this hex. I will explore \_fast_error_exit more in depth later as it's called another time (& there's a decent amount to code to sift through in it).

\__heap_init() itself just uses the HeapCreate function **[5]** with the parameters (a. 0, b. 0x1000, c. 0). These mean, respectively: a. the heap is initialized with no special options, b. with initial size of 0x1000 (4096) bytes, and c. it can grow. \__heap_init() then returns 0 or 1 if the HeapCreate function was unsuccessful or successful, respectively.

---

The next one is \__mtinit(). \__<u>mt</u>init most likely stands for multitask initialization. Combing through the function it doesn't look like it's doing anything past allocating and creating fibers and fiber/thread local storage(F/TLS). I go over fibers and FLS in the **Notes** section.

---

After mtinit, there's \__ioinit(), which I'm assuming is input/output initialiation. The function is pretty long and has a lot of bitwise operations and Critical Section(s?) initialization.

---

Everything after that has to do with setting up/fetching environment variables and setting up its own environment. Nothing that points to mal-operations of any sort, except for \_security_init_cookie() and the anti-forensic function.

### \<END\> Initializers

Continuing to look into XREFs for "terminate_if_debugger_present", I found that it's used in this huge function that seems to have multiple purposes, but one recognizable one is that it tries to update Java. It also opens Registry Keys with the specific location being ""SOFTWARE\\JavaSoft\\Java Update\\Policy\\jucheck". I'm not sure if this is necessarily malicious, as other apps that rely on an up-to-date Java instance might need to run this code too, but I'm not 100% sure. This also could be some sort of misdirection while the program opens up other keys in other threads. One last thing that comes to mind is this might also be a way to trick the user into thinking that the program needs admin privileges to update java in order to view the "pdf" (which is how notPetya usually presents itself as). But all this remains speculation. Nothing I've researched so far has hinted that notPetya even uses Java, so this could also be a C/Windows Runtime thing, or just how Ghidra decompiles binaries (Ghidra is a Java Program).

That being said, terminate_if_debugger_present is used A LOT, so I'll have a lot of combing through to see if there's any other malware-hinting operations tied to this function.

While parsing through the terminate_if_debugger_present I've been noticing a lot of functions that have to do with character manipulation, so that the authors of the malware don't have to write static strings into the program. This is another obfuscation technique. It's very difficult to follow, but there are some interesting tidbits. I found a HttpQueryInfoA call [6] which returns the header information of an HTTP request. The parameters are from the calling function's parameters so it is difficult to follow where the parameter input starts. Not only that, but like I mentioned before, there are a plethora of functions that are obfuscating the input by using bitwise operations on certain characters of a string. Going off of the function calls though, I'm wondering if this is calling back to a C2 server, or at least pinging it to see if it is available.

One other small thing I've noticed is that the program likes to hide damnable strings in the stack as showcased here:

<img title="Strings in Stack" src="images/stringsInStack.png">

This is unsurprising, especially since exploring strings led to no real finds. Not only this, but I think that they store an "encrypted" string on the stack, which is deobfustated in the program.

While looking at the terminate function XREFs I found that Petya accesses the security ID of Windows accounts on the machine its running on with a GetWinAccountDomainSid. Right after that, creates its own security ID with the mode WinAccountDomainUsersSid. I wonder if this is part of privilege escalation.

Further on, there's a call to GetDriveTypeW [7], which does what it's name is, determines the type of drive based on the path you provide. In this instance, it is fed a stack variable, but we can speculate to what this does. It could be searching for any removeable drives in order to read info off of them, or it could be preparing to encrypt the main drive. There may be more functions that deal with the drive that I'll keep an eye out for.

After about 1/3 of the way through the cross-references, the functions become undefined and seem to be almost exactly the same, which could be an issue of operating system compatibility. I'm using Windows 7 to analyze this sample, so the undefined functions could be for Windows 8/10.

### Restoring a Broken Function

There seems to be an odd string type that Ghidra doesn't seem to understand how to decompile. The type is: basic_string\<char,struct_std::char_traits\<char\>,class_std::allocator\<char\>\>. I've never seen or heard of obfuscation dealing with overcomplicating or using obscure data types, but this is what it seems to be. Assuming this is some sort of homemade string variable/structure, I'm going to try to deconstruct it myself. The only reason I'm going to try to do this is because there are multiple instances of this function being used. If was only used once, I wouldn't bother.

Here's the assembly: 
```assembly

  XOR     EAX, EAX
  PUSH    -0x1
  PUSH    EAX
  PUSH    dword ptr [ESP + param_1]
  MOV     dword ptr [ESI + 0x14], 0xf
  MOV     dword ptr [ESI + 0x10], EAX
  MOV     ECX, ESI
  MOV     byte ptr [ESI], AL
  CALL    assign(weird_string_struct param_1, uint param_2, uint param_3) ; I deliberately shortened this since it uses the weird string structure a couple times.
  MOV     EAX, ESI
  RET     0x4 

```

Here's my attempt at decompilation:
```c
weird_string_struct broken_function(weird_string_struct param_1) {
    int a = -1;
    int in_EAX = 0;
    weird_string_struct ref_param_1 = *param_1;
    int b = 0xf;
    int c = in_EAX;

    SOME_STR.assign(param_1, c /* which is 0 */, b /* 15 */);

    return 0x4;
}
```

I know I might be missing a bit here. The two MOV functions before calling assign seem to be placeholding the ESI of broken_function before it moves into assign. Also assign is techniquely "broken" because it also uses the weird_string_struct datatype, but the fact that it is a named function allows for some research, which does yield some results. in [8] we can see that assign has a few different uses, one being used for substring and taking in 3 parameters, the same as the function in our assembly. The only problem is that it doesn't tell us what the parameters are and also what string is calling the "assign" function, but my best guess is in the decompilation above. It seems to copy or assign the first 15 characters of the string param_1 to an unknown string which I've called "SOME_STR". It might be the ref_param_1 that could be calling assign, but that would be the same as if param_1 calling it, which would effectively do nothing. At the very least, this was an exercise to strengthen my knowledge of assembly.


## Notes (more for me to learn, not really useful notPetya info)

Getting into the meat of \__mtinit(), it looks like it has to do heavily with *fibers* and *fiber local storage* (FLS). From what I know about threads (which isn't a whole lot) I know that they are scheduled by the processor (not the program- I think) and ran from the main execution from a process. Fibers [12] are essentially the same thing except they are scheduled and ran by the thread that created them. FLS is essentially the same as thread local storage (TLS), which stores variables and other data structures relevant to a certain thread, except that these variables are available to all fibers in a thread. Fibers are ran when they are "switched to," and I couldn't find anything that described or demonstrated this further other than there is a "SwitchToFiber" function, which probably then executes the fiber's instructions.

***

I've been seeing a lot of std::ios_base use, which I'm unfamiliar. Based on [13], I see that it quite literally is a *base* input/output stream class. Some of these names really are extremely simple. It seems to be locally written, so I wonder if the authors took this base class and built upon it. I specifically stumbled upon a std::ios_base::\_Ios_base_dtor() function, which I'm guessing is a custom written <u>d</u>estruc<u>tor</u> function for an ios_base object. It doesn't seem to be doing anything malicious on top of being a destructor.

## References

[1] https://support.microsoft.com/en-us/topic/description-of-control-panel-cpl-files-4dc809cd-5063-6c6d-3bee-d3f18b2e0176

[2] https://docs.fileformat.com/system/cpl/#:~:text=A%20CPL%20file%20is%20short,Displays%2C%20Networking%2C%20amongst%20others

[3] https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfow (StartupInfoW struct)

[4] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapsetinformation (HeapSetInformation function)

[5] https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapcreate (HeapCreate function)

[6] https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpqueryinfoa

[7] https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getdrivetypew

[8] https://cplusplus.com/reference/string/string/assign/

[12] https://docs.microsoft.com/en-us/windows/win32/procthread/fibers

[13] https://en.cppreference.com/w/cpp/io/ios_base