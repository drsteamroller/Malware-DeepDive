# Notes on Malware Samples

## BINARY.EXE

I'm going to run through the preliminary checks like file and strings.

From File:
>binary.exe; PE32 executable for MS Windows (GUI) Intel 80386 32-bit

From Strings:
> Looks unpacked (CODE and DATA sections visible)
>
> DLLs used:
>
>> 1. adsldpc.dll
>>
>> 2. user32.dll
>>
>> 3. kernel32.dll
>
> Nothing else readable/notable

From PEiD:
> Entrypoint RVA: 0x2B8CC

Now to try IDA Pro. No need to check OllyDBG or Hexplorer, since IDA Pro 
encompasses both of these tools' capabilities.

### Static Analysis

Time to disect binary.exe in IDA

https://reverseengineering.stackexchange.com/questions/13513/are-there-ida-scripts-plugins-to-translate-comment-instructions-to-with-pseudoco

To start off I ran the pe_sections script to seperate the scroll view into
the PE sections.

The entrypoint doesn't look like anything other than stack manipulation, so
it's difficult to tell what it's doing.

Well I decided to debug it anyways. The code is very odd, but I think there are structures
at work here. The first block is comparing varA (I will attach idb with renamed variables)
and if it is greater than integer 14, it will proceed to the next block, else it will continue 
past the next three blocks. I believe that in the next block, the and and move functions both 
involve structures. After researching the 'ds:' I believe it is similar to '[]'. So our structure 
holds anywhere between 3 to 4 values. The and function 'ands' what I named the 'compareAddress'
field of the spX struct. The mov function moves the KiFastSystemCallRet from ntdll.dll
(https://www.processlibrary.com/en/directory/files/ntdll/23004/) THIS DLL DEALS WITH THE
GUI OF WINDOWS, AND CAN IS MENTIONED TO BE A SECURITY RISK -> 
(https://docs.microsoft.com/en-us/security-updates/securitybulletins/2003/ms03-007) Looks like I
may have found something. This vulnerability in ntdll.dll allows for remote code execution.
It is the result of an unchecked buffer component of ntdll.dll.
This could be a possibility, but it also could be using ntdll.dll normally. I checked the
system for a "World Wide Web Publishing" (the vulnerable component) and couldn't find it.
Here is the structure of the 2 "alleged" structs in the second block:
```c 
struct Address {
	unsigned int unused = 0x0; // not used (yet)
	unsigned int result_from_compare = 0x0; // This one is used with the AND function with ECX
	unsigned int holdAddress = 0x0; // This one is used with the MOV function and EDX
	unsigned int unused2 = 0x0;
}
```
After the ADD and MOV functions, we compare BH, which are the last 4 bytes in EBX (little endian)
these are 0xA0, and it compares it with a byte pointer, datZ (which is zero). It'll jump to 
the next block if BH is greater than or equal to datZ. 

Digressing a little bit, I found that the subroutines would make it impossible to create the
pseudocode and be able to understand it as whole, subroutine 40295C is \~2KB. As pointed out in 
Dynamic Analysis, I found out that it creates a .bat file in the TEMP directory, which I would
like to capture. I can rely on Ghidra's output for the pseudocode if need be.

### Dynamic Analysis

Running the program with Wireshark and ProcMon open:

Nothing seems to pop up other than the program deletes itself sometime
after being run. I retried it while TCPView was open, which also didn't reveal
anything.

After thorough analysis of the applications "Process Monitor" and "Process Explorer":
I found that it takes a bunch of CPU power, and then promptly deletes itself. I can then
see in Process Monitor that it tries to access a BUNCH of files. There are a bunch of 
NAME NOT FOUND results. It also read kernel32.dll successfully. Before that it reads offsets
(decimal) 144384, 176128, 17408, and 1024 in it's own file. It then tries to open a bunch of files
whose names look like obfuscated strings (I saw these in the output of "Strings") that are
in its own directory (the one we ran it out of). Its actually only 6 different files with the names:
> dtt
>
> CNiqn
>
> fjZkV
>
> pAJsSnPC
>
> evmsxBDXF
>
> HCJpGEzA0ONBHSlb
>

It loops over these over and over. There are also a few different ones it throws in from time to time
I'm not sure how many extraneous ones there are though.
It also opens adsldpc.dll (seems to modify) and wldap32.dll (only opens)
After this the next legitimate action it takes is it reads the following offsets in itself:

> 50176
>
> 82944
>
> 115712
>

At the very end it seems to do a few things. It looks like it tries and fails(?) to take control of the
DeviceIoControl of C:\WINDOWS. Then it creates another version of itself in the same path, then makes a 
.bat file in the \~\Local Settings\Temp directory called tmp76dc7e71.bat. It wasn't in the directory upon
inspection. it access a few DLLs and then towards the very end of its operation I saw a BUFFER OVERFLOW
result upon a QueryNameInformationFile on cmd.exe. Then it runs the BAT file from the command line. I 
can try to capture this file from debugging the program in IDA.

## WINHLP.EXE (blatant keylogger)

So initial looks into this file found that the file was broken somehow. It looked fine from a
glance, but I checked each section, and saw that the magic number was NZ instead of MZ. Fixing 
this allowed PEiD, and another similar tool (for linux) Detect it Easy to work. The entrypoint is 0x1219,
the section is .text. From Detect it Easy, I found the exact compiler and linker that it used, and
using those, I can make the pseudocode that comes out of Ghidra easy to read.

### Static Analysis

From Strings, the most damning evidence found is strings for "keylogger" among other things like "password",
not much else stuck out. I need to be careful to not look at the disassembly/decompilation code through a 
keylogger lens. It could be a diversion.

Ghidra: Glancing just at the entry/main function, we can see a bunch of variable declarations. Ghidra
does this thing where whenever the assembly assigns/pushes values onto certain areas of the stack, it declares
variables for those positions in the decompiled pseudocode.

The external functions used by this program, starting in the main function we have "GetMainArgs" which
seems to be imported from CRTDLL.DLL
> CRTDLL.DLL -> [<u>C</u> <u>R</u>un<u>T</u>ime]DLL.DLL
> contains functions for C like printf, memcpy, etc
> it uses the function mentioned above "GetMainArgs" This enables command line parsing and grabs and
> passes anything found to main(). There are three variables pushed onto the stack, and I know that
> 2 of them have to be argC (argument count) and argV (argument values/list) the third one I named
> "env?" since that's the third parameter's name in the function API. It looks as if this variable
> changes right after the function call, so it might be unrelated. I'm wondering if this is an
> obfuscation tactic.

The second defined function declares 2 variables, and one of them is peculiar. This is the LPSTR variable.
If you look at the document for this certain variable, there is one thing that sticks out to me.
This is that it could end in a null terminator ('\0'), but that its not a requirement. We know that 
given a sample of enough users, their key input is completely random. We don't know any specific
length of input that can describe any certain person. So this variable might be the one that captures
the input, so I named it aptly: "captureInput?" with a question mark since I wasn't entirely certain
that it was for this purpose. With this variable, the program sets it equal to the output of the function
GetCommandLineA:

> The return value is a pointer to the command-line string for the current process.

Looking further into this, I'm going to change "captureInput" to "getProcName" since it looks like
this function is analyzing the Process Name returned by GetCommandLineA. If getProcName starts with "\"", 
It uses a char variable to change the last occurence of " **"** " (quotation mark) to a null
terminator. Else, it seems to just scroll to the end of the string. It's composed of 2 for loops where
the conditional statement checks if the current character of getProcName isn't "\0" and " ", which is
odd because a character cannot be 2 different values at once, so this must serve to either obfuscate
and/or just get to the string. The program then calls the function "GetModuleHandleA" with the
(LPCSTR) casted value of 0x0. LPCSTR is just a 32 bit pointer to a null terminated string. Reading
the document for it, it is obvious that this isn't for any real purpose other than to obfuscate and
mislead. There hasn't been a module handle created by this program, and 0x0 (NULL BYTE) isn't a valid
module name. The calling process must have created the module being passed to GetModuleHandleA. The
program then enters into another local function.

The next function seems to be the meat and potatoes of the program. It contains all the damnable strings
in the output of the tool 'strings'. I could also see by digging into some of the other function calls
that the malware creates registry keys, and also uses wsock32.dll, a networking DLL file for C/C++.
This tells me that I should take a look at this in wireshark while I run it.

There's an interesting locally defined string in the program called s_wind0ws.exe which equals 
"wind0ws.exe" theres also s_password and s_#help which are "password" and "#help", respectively.

The program gets the path to the system directory (big red flag) 

There's a few more imported functions, SetFileAttributesA which is passed a local variable that is of
the C formatted string "%s\\\\%s". It also does the ShellExecuteA command which has the following
options: edit, explore, find, open, print, runas (administrator), and NULL.

I've been jumping around a lot and found a local function which was 883 lines of pseudocode. Best to
debug it instead of interpret it.

Later on in the long function, I found that the program messes with WSAStartup, which seems to commence
the networking of the program. They must capture user input and send it off to a adversary server.

Then I found a URL! "s_irc.efnet.org" IRC is internet relay chat, which is used to send commands
to the victim's computer in other malware's cases. This could be where the ShellExecuteA gets its
options. It seems like the attacker can send certain commands that do certain actions. one of them
makes the program wait for 5 hours until inquiring again. The others are a little more complex.

At the end of the program, it ends the networking session.

### Dynamic Analysis

Wireshark/TCPView:
Right away we can see that the program gets its networking bearing, then it tries to contact irc.efnet.org
as well as irc.servercentral.net. This is the way that the hackers would communicate with a victim machine
Though it does seem automated. The program requests a user "NICK" and this user responds with a bunch of NOTICE responses and then a "No Takeovers"... "No Whiners". I wonder if this is some sort of flag for
this malware, or the person/people who maintained this malware shut it down, but left this message.

Upon Run:
So right off the bat, it creates a thread, so I'm guessing that GetMainArgs command creates a thread.
It seems like the program tries to find a RegKey, because it fails twice, and then succeeds the third
time. I can see that it tries to open DLLs in its home file (on the Desktop) before trying the system
folder. It loads ws2_32.dll and wsock32.dll for networking, and then some that are unfamiliar to me:
advapi32.dll, rpct4.dll, secur32.dll, msvcrt.dll, ws2help.dll, shell32.dll, gdi32.dll, user32.dll,
shlwapi.dll, winmm.dll, and ~~crtdll.dll~~. It does a lot of openning registry keys in the beginning.

A little later on I can see that it walks through the drivers of the system, first it goes through the
audio drivers wave, midi, aux, and mixer. This is kinda scary, since it might mean that the program is
trying to listen using any audio devices that the computer might have.

Something interesting it does next is it sets the random seed of the cryptography\RNG path. I'm 
wondering if the purpose of this is to essentially make the system more predictable as whole, but I'm not 
sure what regular user processes use random functions unless they are targetting users that code as well.

Then crypt32.dll and msasn1.dll are loaded, and then wininet.dll and oleaut32.dll. 

After this, it looks like it begins its networking process, which is addressed in the Wireshark/TCPView
analysis. It looks like the SetFileAttributesA found in Static Analysis was for the wind0ws.exe that
was also found in Static Analysis. It's created here. I did end up finding it in the system32 folder.

It does a lot of bouncing around on the computer's hard drive, including my home directory. After this,
it goes on a long binge of flipping through registry keys, and doesn't seem to do anything noticeable.
I was able to capture the wind0ws.exe file, and the first thing I did was take the SHA-256 of it and 
winhlp.exe and I found that they were the same, meaning it just copies itself elsewhere with a different
name.